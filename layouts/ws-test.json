{
  "b": 209,
  "disableInputWhenNotFocused": true,
  "mangledName": "WS_32test",
  "name": "WS test",
  "oglFOV": 90,
  "oglZFar": 500,
  "oglZNear": 1,
  "r": 209,
  "standardSortMethod": true,
  "stopSoundsOnStartup": true,
  "title": "",
  "v": 209,
  "uiSettings": {
    "grid": false,
    "gridB": 255,
    "gridG": 180,
    "gridHeight": 32,
    "gridOffsetX": 0,
    "gridOffsetY": 0,
    "gridR": 158,
    "gridType": "rectangular",
    "gridWidth": 32,
    "snap": true,
    "windowMask": false,
    "zoomFactor": 1
  },
  "objectsGroups": [],
  "variables": [],
  "instances": [
    {
      "angle": 0,
      "customSize": false,
      "height": 0,
      "layer": "",
      "locked": false,
      "name": "NewObject",
      "persistentUuid": "6a4fb2bb-77f1-4be6-95c4-e11e741c9295",
      "width": 0,
      "x": 780,
      "y": 390,
      "zOrder": 1,
      "numberProperties": [],
      "stringProperties": [],
      "initialVariables": []
    },
    {
      "angle": 0,
      "customSize": false,
      "height": 0,
      "layer": "",
      "locked": false,
      "name": "Clock",
      "persistentUuid": "8b9269c7-9d3f-4dc7-ab5f-85cef69d035d",
      "width": 0,
      "x": 819,
      "y": 705,
      "zOrder": 2,
      "numberProperties": [],
      "stringProperties": [],
      "initialVariables": []
    }
  ],
  "objects": [
    {
      "bold": false,
      "italic": false,
      "name": "NewObject",
      "smoothed": true,
      "tags": "",
      "type": "TextObject::Text",
      "underlined": false,
      "variables": [],
      "behaviors": [],
      "string": "Text",
      "font": "",
      "characterSize": 20,
      "color": {
        "b": 0,
        "g": 0,
        "r": 0
      }
    },
    {
      "name": "Clock",
      "tags": "",
      "type": "PrimitiveDrawing::Drawer",
      "variables": [],
      "behaviors": [],
      "fillOpacity": 255,
      "outlineSize": 1,
      "outlineOpacity": 255,
      "fillColor": {
        "b": 255,
        "g": 255,
        "r": 255
      },
      "outlineColor": {
        "b": 0,
        "g": 0,
        "r": 0
      },
      "absoluteCoordinates": false,
      "clearBetweenFrames": true
    }
  ],
  "events": [
    {
      "colorB": 228,
      "colorG": 176,
      "colorR": 74,
      "creationTime": 0,
      "disabled": false,
      "folded": false,
      "name": "",
      "source": "",
      "type": "BuiltinCommonInstructions::Group",
      "events": [
        {
          "disabled": true,
          "folded": true,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const vars = runtimeScene.getVariables()\nconst wsVar = vars.get('WS')\nconst secVar = vars.get('Sec')\n\n// const ws = new WebSocket('ws://sangervasi.net')\nconst ws = new WebSocket('ws://localhost:42992')\n\nlet t = Date.now()\n\nsetInterval(() => {\n    ws.send('client says')\n}, 500)\n\nws.addEventListener('message', (messageEvent) => {\n    const data = JSON.parse(messageEvent.data.toString())\n    console.log('client heard:', data)\n    const ts = (Date.now() - t) / 1000 \n    wsVar.setString(JSON.stringify({\n        ts,\n        data\n    }, null, 2))\n    secVar.setNumber(ts)\n})",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        },
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "class s {\n\tconstructor(s) {\n\t\t;(this.M = null), (this.P = null), (this.T = s)\n\t}\n\ttype(e) {\n\t\treturn new s(e)\n\t}\n\tpayload() {\n\t\treturn new s(this.T)\n\t}\n\tmessage(s) {\n\t\treturn this.T === s.type\n\t}\n\tbuild(s) {\n\t\treturn s\n\t}\n}\nconst e = new s(''),\n\tt = e.type('echo').payload(),\n\tn = e.type('gnop.join').payload(),\n\to = e.type('gnop.joined').payload(),\n\ti = e.type('gnop.point').payload(),\n\ta = e.type('session.created').payload()\ne.type('session.closed').payload()\nconst r = () => {\n\tconst s = {}\n\treturn (\n\t\t(s.promise = new Promise((e, t) => {\n\t\t\t;(s.resolve = e), (s.reject = t)\n\t\t})),\n\t\ts\n\t)\n}\nObject.assign(globalThis, {\n\tGnop: {\n\t\tWsClient: class {\n\t\t\tconstructor(s) {\n\t\t\t\t;(this.options = s),\n\t\t\t\t\t(this.state = 'init'),\n\t\t\t\t\t(this.promises = {}),\n\t\t\t\t\t(this.handleMessage = s => {\n\t\t\t\t\t\tconst e = (s => {\n\t\t\t\t\t\t\tlet e,\n\t\t\t\t\t\t\t\tt = ''\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\te = JSON.parse(s.toString())\n\t\t\t\t\t\t\t} catch (s) {\n\t\t\t\t\t\t\t\tt = s.message\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn '' !== t\n\t\t\t\t\t\t\t\t? { type: 'error', sessionUuid: '', payload: { error: t } }\n\t\t\t\t\t\t\t\t: 'object' == typeof (n = e) && null !== n && 'type' in n\n\t\t\t\t\t\t\t\t? e\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\t\t\t\t\tsessionUuid: '',\n\t\t\t\t\t\t\t\t\t\tpayload: { error: 'Invalid message structure' },\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\tvar n\n\t\t\t\t\t\t})(s.data)\n\t\t\t\t\t\tvar n, i\n\t\t\t\t\t\t'creating' !== this.state\n\t\t\t\t\t\t\t? 'joining' !== this.state\n\t\t\t\t\t\t\t\t? t.message(e)\n\t\t\t\t\t\t\t\t\t? console.log('client heard:', e)\n\t\t\t\t\t\t\t\t\t: console.warn('Unhandled messag:', e)\n\t\t\t\t\t\t\t\t: o.message(e)\n\t\t\t\t\t\t\t\t? (console.log('Joined', this.sessionUuid),\n\t\t\t\t\t\t\t\t  (this.state = 'joined'),\n\t\t\t\t\t\t\t\t  null == (n = this.promises.join) || n.resolve())\n\t\t\t\t\t\t\t\t: console.warn('Expected joined message, got:', e)\n\t\t\t\t\t\t\t: a.message(e)\n\t\t\t\t\t\t\t? (console.info('Created', e.sessionUuid),\n\t\t\t\t\t\t\t  (this.state = 'created'),\n\t\t\t\t\t\t\t  (this.sessionUuid = e.sessionUuid),\n\t\t\t\t\t\t\t  null == (i = this.promises.connect) || i.resolve())\n\t\t\t\t\t\t\t: console.warn('Expected created message, got:', e)\n\t\t\t\t\t}),\n\t\t\t\t\t(this.handleOpen = () => {\n\t\t\t\t\t\tconsole.info('Opened')\n\t\t\t\t\t}),\n\t\t\t\t\t(this.handleClose = () => {\n\t\t\t\t\t\t;(this.state = 'init'), console.info('Closed')\n\t\t\t\t\t}),\n\t\t\t\t\t(this.handleError = () => {\n\t\t\t\t\t\t;(this.state = 'init'), console.info('Errored')\n\t\t\t\t\t})\n\t\t\t}\n\t\t\tasync connect() {\n\t\t\t\tconsole.log('Connecting')\n\t\t\t\tconst s = new WebSocket(this.options.host)\n\t\t\t\treturn (\n\t\t\t\t\t(this.ws = s),\n\t\t\t\t\t(s.onopen = this.handleOpen),\n\t\t\t\t\t(s.onclose = this.handleClose),\n\t\t\t\t\t(s.onerror = this.handleError),\n\t\t\t\t\ts.addEventListener('message', this.handleMessage),\n\t\t\t\t\t(this.state = 'creating'),\n\t\t\t\t\t(this.promises.connect = r()),\n\t\t\t\t\tthis.promises.connect\n\t\t\t\t)\n\t\t\t}\n\t\t\tisReady() {\n\t\t\t\treturn (\n\t\t\t\t\tBoolean(this.sessionUuid) &&\n\t\t\t\t\tBoolean(this.ws) &&\n\t\t\t\t\t'created' === this.state\n\t\t\t\t)\n\t\t\t}\n\t\t\tasync join() {\n\t\t\t\tif (!this.isReady())\n\t\t\t\t\treturn void console.warn('Cannot join from state:', this.state)\n\t\t\t\tconst s = n.build({\n\t\t\t\t\ttype: 'gnop.join',\n\t\t\t\t\tsessionUuid: this.sessionUuid,\n\t\t\t\t\tpayload: { name: this.options.name || 'Name' },\n\t\t\t\t})\n\t\t\t\treturn (\n\t\t\t\t\tconsole.info('Client joining:', s),\n\t\t\t\t\t(this.state = 'joining'),\n\t\t\t\t\tthis.ws.send(JSON.stringify(s)),\n\t\t\t\t\t(this.promises.join = r()),\n\t\t\t\t\tthis.promises.join\n\t\t\t\t)\n\t\t\t}\n\t\t\tspeak() {\n\t\t\t\tif (!this.isReady())\n\t\t\t\t\treturn void console.warn('Cannot speak from state:', this.state)\n\t\t\t\tconst s = t.build({\n\t\t\t\t\ttype: 'echo',\n\t\t\t\t\tsessionUuid: this.sessionUuid,\n\t\t\t\t\tpayload: new Date().toISOString(),\n\t\t\t\t})\n\t\t\t\tconsole.info('Client speaking:', s), this.ws.send(JSON.stringify(s))\n\t\t\t}\n\t\t\tpoint(s, e) {\n\t\t\t\tif (!this.isReady())\n\t\t\t\t\treturn void console.warn('Cannot send point from state:', this.state)\n\t\t\t\tconst t = i.build({\n\t\t\t\t\ttype: 'gnop.point',\n\t\t\t\t\tsessionUuid: this.sessionUuid,\n\t\t\t\t\tpayload: { x: s, y: e },\n\t\t\t\t})\n\t\t\t\tconsole.info('Client sending point:', t),\n\t\t\t\t\tthis.ws.send(JSON.stringify(t))\n\t\t\t}\n\t\t},\n\t},\n})\n//# sourceMappingURL=gnop.modern.js.map\n",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        },
        {
          "disabled": true,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const parseMessage = raw => {\n  let parsed;\n  let parseError = '';\n\n  try {\n    parsed = JSON.parse(raw.toString());\n  } catch (e) {\n    parseError = e.message;\n  }\n\n  if (parseError !== '') {\n    return {\n      type: 'error',\n      sessionUuid: '',\n      payload: {\n        error: parseError\n      }\n    };\n  }\n\n  if (!isMessage(parsed)) {\n    return {\n      type: 'error',\n      sessionUuid: '',\n      payload: {\n        error: 'Invalid message structure'\n      }\n    };\n  }\n\n  return parsed;\n};\nconst isMessage = obj => {\n  if (typeof obj !== 'object') {\n    return false;\n  }\n\n  if (obj === null) {\n    return false;\n  }\n\n  if (!('type' in obj)) {\n    return false;\n  }\n\n  return true;\n};\nclass Guard {\n  constructor(t) {\n    this.M = null;\n    this.P = null;\n    this.T = t;\n  }\n\n  type(t) {\n    return new Guard(t);\n  }\n\n  payload() {\n    return new Guard(this.T);\n  }\n\n  message(m) {\n    return this.T === m.type;\n  }\n\n  build(m) {\n    return m;\n  }\n\n}\nconst guard = new Guard('');\n\nconst guardEcho = guard.type('echo').payload();\n\nconst guardJoin = guard.type('gnop.join').payload();\nconst guardJoined = guard.type('gnop.joined').payload();\nconst guardPoint = guard.type('gnop.point').payload();\n\nconst guardCreated = guard.type('session.created').payload();\nguard.type('session.closed').payload();\n\nconst metafy = () => {\n  const meta = {};\n  meta.promise = new Promise((resolve, reject) => {\n    meta.resolve = resolve;\n    meta.reject = reject;\n  });\n  return meta;\n};\n\nclass WsClient {\n  constructor(options) {\n    this.options = options;\n    this.state = \"init\";\n    this.promises = {};\n\n    this.handleMessage = event => {\n      const message = parseMessage(event.data);\n\n      if (this.state === \"creating\") {\n        if (guardCreated.message(message)) {\n          var _this$promises$connec;\n\n          console.info('Created', message.sessionUuid);\n          this.state = \"created\";\n          this.sessionUuid = message.sessionUuid;\n          (_this$promises$connec = this.promises.connect) == null ? void 0 : _this$promises$connec.resolve();\n        } else {\n          console.warn('Expected created message, got:', message);\n        }\n\n        return;\n      }\n\n      if (this.state === \"joining\") {\n        if (guardJoined.message(message)) {\n          var _this$promises$join;\n\n          console.log('Joined', this.sessionUuid);\n          this.state = \"joined\";\n          (_this$promises$join = this.promises.join) == null ? void 0 : _this$promises$join.resolve();\n        } else {\n          console.warn('Expected joined message, got:', message);\n        }\n\n        return;\n      }\n\n      if (guardEcho.message(message)) {\n        console.log('client heard:', message);\n        return;\n      }\n\n      console.warn('Unhandled messag:', message);\n    };\n\n    this.handleOpen = () => {\n      console.info('Opened');\n    };\n\n    this.handleClose = () => {\n      this.state = 'init';\n      console.info('Closed');\n    };\n\n    this.handleError = () => {\n      this.state = 'init';\n      console.info('Errored');\n    };\n  }\n\n  async connect() {\n    console.log('Connecting');\n    const ws = new WebSocket(this.options.host);\n    this.ws = ws;\n    ws.onopen = this.handleOpen;\n    ws.onclose = this.handleClose;\n    ws.onerror = this.handleError;\n    ws.addEventListener('message', this.handleMessage);\n    this.state = \"creating\";\n    this.promises.connect = metafy();\n    return this.promises.connect;\n  }\n\n  isReady() {\n    return Boolean(this.sessionUuid) && Boolean(this.ws) && this.state === \"created\";\n  }\n\n  async join() {\n    if (!this.isReady()) {\n      console.warn('Cannot join from state:', this.state);\n      return;\n    }\n\n    const mJoin = guardJoin.build({\n      type: 'gnop.join',\n      sessionUuid: this.sessionUuid,\n      payload: {\n        name: this.options.name || \"Name\"\n      }\n    });\n    console.info('Client joining:', mJoin);\n    this.state = \"joining\";\n    this.ws.send(JSON.stringify(mJoin));\n    this.promises.join = metafy();\n    return this.promises.join;\n  }\n\n  speak() {\n    if (!this.isReady()) {\n      console.warn('Cannot speak from state:', this.state);\n      return;\n    }\n\n    const m = guardEcho.build({\n      type: 'echo',\n      sessionUuid: this.sessionUuid,\n      payload: new Date().toISOString()\n    });\n    console.info('Client speaking:', m);\n    this.ws.send(JSON.stringify(m));\n  }\n\n  point(x, y) {\n    if (!this.isReady()) {\n      console.warn('Cannot send point from state:', this.state);\n      return;\n    }\n\n    const mPoint = guardPoint.build({\n      type: 'gnop.point',\n      sessionUuid: this.sessionUuid,\n      payload: {\n        x: x,\n        y: y\n      }\n    });\n    console.info('Client sending point:', mPoint);\n    this.ws.send(JSON.stringify(mPoint));\n  }\n\n}\n\nconst Gnop = {\n  WsClient\n};\nObject.assign(globalThis, {\n  Gnop\n});\n//# sourceMappingURL=gnop.js.map\n",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        },
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "const { Gnop } = globalThis\n\nconst vars = runtimeScene.getVariables()\nconst wsVar = vars.get('WS')\n\nwsVar.setString(Gnop.WsClient ? \"Has client\" : \"No client\")\n",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": []
    },
    {
      "colorB": 228,
      "colorG": 176,
      "colorR": 74,
      "creationTime": 0,
      "disabled": false,
      "folded": false,
      "name": "",
      "source": "",
      "type": "BuiltinCommonInstructions::Group",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "inverted": false,
                "value": "TextObject::String"
              },
              "parameters": [
                "NewObject",
                "=",
                "VariableString(WS)"
              ],
              "subInstructions": []
            }
          ],
          "events": []
        },
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "inverted": false,
                "value": "PrimitiveDrawing::Circle"
              },
              "parameters": [
                "Clock",
                "0",
                "0",
                "100"
              ],
              "subInstructions": []
            }
          ],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "ModVarScene"
                  },
                  "parameters": [
                    "Deg",
                    "=",
                    "ToRad(-90 + (360 / 60) * Variable(Sec))"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            },
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "inverted": false,
                    "value": "PrimitiveDrawing::LineV2"
                  },
                  "parameters": [
                    "Clock",
                    "100",
                    "100",
                    "100 * (1 + cos(Variable(Deg)))",
                    "100 * (1 + sin(Variable(Deg)))",
                    "10"
                  ],
                  "subInstructions": []
                }
              ],
              "events": []
            },
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": []
            }
          ]
        }
      ],
      "parameters": []
    }
  ],
  "layers": [
    {
      "ambientLightColorB": 0,
      "ambientLightColorG": 0,
      "ambientLightColorR": 0,
      "followBaseLayerCamera": false,
      "isLightingLayer": false,
      "name": "",
      "visibility": true,
      "cameras": [
        {
          "defaultSize": true,
          "defaultViewport": true,
          "height": 0,
          "viewportBottom": 1,
          "viewportLeft": 0,
          "viewportRight": 1,
          "viewportTop": 0,
          "width": 0
        }
      ],
      "effects": []
    }
  ],
  "behaviorsSharedData": []
}